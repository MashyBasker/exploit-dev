## General pointers

### 1. x86, CPU and memories

- a 32-bit CPU executes 4 byte instructions one after the another as fetched by the CPU cycle.
- address and data are both stored as hex.
- most attacks are focussed on 32-bit architecture machines because 64 bit machines are backward compatible and if the exploit runs on a 32 bit machine, then it can also run  in a 64 bit machine.

**1.1 Components of a CPU**
```mermaid
graph TD;
    1[Control Unit];
    2[Execution Unit];
    3[Registers];
    4[Flags];
    1---2;
    2---3;
    2---4;
```

### 2. Registers

> **Note**: The CPU has EIP register to store the next machine instruction. If we can manipulate this EIP register, we can do nasty things. This is a popular malware technique.

**2.1 General Purpose Registers**

These are registers are for storing data temporarily.

`eax`: also known as *accumulator*. Stores the result after arithmetic operations and function return values.

`ebx`: points to the data segment. It is the base pointer for memory access.

`ecx`: counter register. Used to maintain count. Used for looping and string operations.

`edx`: used for I/O operations. Extends `eax` to 64-bit

`esi`: source index register. For address and memory copying. Stores the base address of the string or array to be copied.

`edi`: destination index register. Stores the destination address for the string or array to be copied.

`ebp`: base pointer. a register pointing to the bottom of the stack.

`esp`: stack pointer. a register pointing to the top of the stack.

**2.2 Registers and their sizes**

`eax` is a 32-bit register. It's 16-bit equivalent is `ax`. `ax` can be further divided into `ah` and `al` representing the high and low pair respectively.

```
+-------------------------------------+
|                 |    AH    |    AL  |
|                 |<------- AX ------>|           
|                 |       16-bit      |
<--------------- EAX ----------------->
                     32-bit
```

Registers like ESI, EDI, EBP and ESP have are 32-bits but can be broken down to their 16-bit representative i.e SI, DI, BP and SP.

**2.3 Segment Registers**

Use to reference memory location.

- `CS`: Code segment. Store the base location of the code(`.text` section)
- `DS`: Data segment. Store the location of variables (`.data` section)
- `ES`: Extra segment. Used for string operations
- `SS`: Stack segment. Stores based location of stack. Used when we use `esp`/`ebp`
- `FS`: Extra stuff.
- `GS`: Extra stuff.

 All these registers are 16-bit. Registers have the base location of their respective segments. None of these registers can be explicitly loaded or changed because are considered part of the operating system.


**2.4 Control Registers**

These are used to determine the CPU operating mode(User mode or Kernel mode).

- `CRO`: controls the operating mode and CPU state
- `CR2`: memory page fault info
- `CR3`: memory page directory info
- `CR4`: flags for enabling processor feathers and indicate processor capabilities

`CR1` has not yet been implemented.

These register values cannot be read directly. But they can be moved to the general purpose registers.

**2.5 Flags**

Used to verify if the operations performed by the processor is successful or not.

### 3. Memory

**3.1 Stack**

When a program executes, a certain contiguous segment of memory is set for it called the *stack*.

- stack pointer points to the top of the stack
- stack pointer to the smallest possible address. Anything lesser than that is garbage, and anything greater than that is valid
- stack has 2 operations. Push and pop.
- stack grows downwards(counter-intuitive)

Therefore, the top of the stack is the downmost address.

**3.2 Heap**

This region of the memory is not automatically managed by the computer and should be done manually. In C, functions like `malloc` and `calloc` exists for this purpose, and `free` to free this memory, otherwise a memory leak can occur.

Heap memory is free-floating, and does not have any size restrictions like the stack.

It is good for using dynamic-sized variables like dynamic arrays, structs, etc. 