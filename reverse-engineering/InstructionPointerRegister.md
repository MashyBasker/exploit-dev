The Instruction Pointer Register(`eip`) is the single most important register in reverse engineering. Manipulating it can let us run code that we are not supposed to run.

### Demo

Consider the program `ipr.c`. The program has a main function and a hidden function which is never called. But by manipulating the `eip` register, we can execute the `hiddenFunction` as well.

First we need to compile the program to work with the IA-32 instruction set.

```console
gcc -m32 -ggdb -o eipDemo ipr.c
```

Executing the binary will just result in displaying of the message "hello world!". But we can more with `gdb`.

```
gdb ./eipDemo
```

We set the assembly flavor to intel and a breakpoint at main.

```
(gdb) set disassembly-flavor intel
(gdb) b main
Breakpoint 1 at 0x11d4: file ipr.c, line 10.
(gdb) r
Starting program: /home/okabe/projects/exploit-dev/reverse-engineering/eip

Breakpoint 1, main () at ipr.c:10
10		printf("hello world!\n");
(gdb) disas
Dump of assembler code for function main:
   0x565561bb <+0>:	lea    ecx,[esp+0x4]
   0x565561bf <+4>:	and    esp,0xfffffff0
   0x565561c2 <+7>:	push   DWORD PTR [ecx-0x4]
   0x565561c5 <+10>:	push   ebp
   0x565561c6 <+11>:	mov    ebp,esp
   0x565561c8 <+13>:	push   ebx
   0x565561c9 <+14>:	push   ecx
   0x565561ca <+15>:	call   0x565561f7 <__x86.get_pc_thunk.ax>
   0x565561cf <+20>:	add    eax,0x2e25
=> 0x565561d4 <+25>:	sub    esp,0xc
   0x565561d7 <+28>:	lea    edx,[eax-0x1fd2]
   0x565561dd <+34>:	push   edx
   0x565561de <+35>:	mov    ebx,eax
   0x565561e0 <+37>:	call   0x56556040 <puts@plt>
   0x565561e5 <+42>:	add    esp,0x10
   0x565561e8 <+45>:	mov    eax,0x0
   0x565561ed <+50>:	lea    esp,[ebp-0x8]
   0x565561f0 <+53>:	pop    ecx
   0x565561f1 <+54>:	pop    ebx
   0x565561f2 <+55>:	pop    ebp
   0x565561f3 <+56>:	lea    esp,[ecx-0x4]
   0x565561f6 <+59>:	ret
End of assembler dump.
```

The `=>` symbol indicates the breakpoint, which is the main function. Continuing, we get the "hello world!" message.

```
(gdb) c
Continuing.
hello world!
[Inferior 1 (process 55506) exited normally]
(gdb) r
Starting program: /home/okabe/projects/exploit-dev/reverse-engineering/eip
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Breakpoint 1, main () at ipr.c:10
10		printf("hello world!\n");
```

We examine where the `eip` is:

```
(gdb) x/1xw $eip
0x565561d4 <main+25>:	0x8d0cec83
```

Now we try to disassemble the unreacheable function `hiddenFunction`

```
(gdb) disas hiddenFunction
Dump of assembler code for function hiddenFunction:
   0x5655618d <+0>:	push   ebp
   0x5655618e <+1>:	mov    ebp,esp
   0x56556190 <+3>:	push   ebx
   0x56556191 <+4>:	sub    esp,0x4
   0x56556194 <+7>:	call   0x56556090 <__x86.get_pc_thunk.bx>
   0x56556199 <+12>:	add    ebx,0x2e5b
   0x5655619f <+18>:	sub    esp,0xc
   0x565561a2 <+21>:	lea    eax,[ebx-0x1fec]
   0x565561a8 <+27>:	push   eax
   0x565561a9 <+28>:	call   0x56556040 <puts@plt>
   0x565561ae <+33>:	add    esp,0x10
   0x565561b1 <+36>:	sub    esp,0xc
   0x565561b4 <+39>:	push   0x0
   0x565561b6 <+41>:	call   0x56556050 <exit@plt>
End of assembler dump.
```

Ah. Now we have the address to the start of the `hiddenFunction`(`0x5655618d`)

Now we set the `eip` register to the start of hiddenFunction.

```
(gdb) set $eip=0x5655618d
(gdb) x/1xw $eip
0x5655618d <hiddenFunction>:	0x53e58955
```

Continuing now, we can execute the `hiddenFunction`

```
(gdb) set $eip=0x5655618d
(gdb) x/1xw $eip
0x5655618d <hiddenFunction>:	0x53e58955
(gdb) c
Continuing.
This is a hidden function
[Inferior 1 (process 57528) exited normally]
```

We've hacked the program. Making it run instructions it isn't supposed to!
